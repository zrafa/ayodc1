\documentclass[glossy]{beamer}
\useoutertheme{wuerzburg}
\useinnertheme[realshadow,corners=2pt,padding=2pt]{chamfered}
\usecolortheme{shark}

\usepackage{listings}

\usepackage{tikz}
\newcommand<>{\hover}[1]{\uncover#2{%
 \begin{tikzpicture}[remember picture,overlay]%
 \draw[fill,opacity=0.4] (current page.south west)
 rectangle (current page.north east);
 \node at (current page.center) {#1};
 \end{tikzpicture}}
}

\title{Arquitecturas y Organización de Computadoras I \\\line(1,0){320}}
% \author{\texorpdfstring{Author\newline\url{email@email.com}}{Author}}
%\author{Rafael Ignacio Zurita}
\institute{Rafael Ignacio Zurita \\ Departamento de Ingenieria de Computadoras - FAI - UNCOMA 2018 \\ Clase presencial 2}
%\date{\today}



\begin{document}




\begin{frame}
\maketitle
\end{frame}

\institute{Departamento de Ingenieria de Computadoras - FAI - UNCOMA \\ 2018}

\begin{frame}
\frametitle{Programa Analítico}
\textbf{UNIDAD I: Arquitectura y Organización de Computadoras}
 \\~\\
\textit{Organización  funcional. Repaso del modelo de Von Neumann. Concepto de Arquitectura y Organización de Computadoras. Representación de datos a nivel de máquina. Direccionamiento de memoria: concepto de palabra, ordenamiento de bytes. Registros.} 
 \\~\\
Formatos de Instrucciones. Modos de direccionamiento. Tipos de instrucciones: transferencia de datos, operaciones aritméticas y lógicas, transferencia de control. Excepciones. Lenguaje ensamblador: directivas, operaciones, pseudo-operaciones, macros.
\end{frame}


\begin{frame}
\frametitle{Arquitecturas y Organización de Computadoras}
\textbf{Programación de la máquina}
\begin{itemize}
	\item Origen del concepto Arquitectura y Organización (nuevamente)
	\item El lenguaje de la máquina
	\item Evolucion: CISC, RISC, multiprocesadores
\end{itemize}
\end{frame}


\begin{frame}
\frametitle{Arquitecturas y Organización de Computadoras}
\textbf{Programación de la máquina}
\begin{itemize}
	\item \textbf{Origen del concepto Arquitectura y Organización (nuevamente)}
	\item El lenguaje de la máquina
	\item Evolucion: CISC, RISC, multiprocesadores
\end{itemize}
\end{frame}



\begin{frame}
\frametitle{Arquitecturas y Organización de Computadoras}
\textbf{Modelo de programación}
	\textit{Para programar una computadora se debe comprender los registros de la CPU, la organización de la memoria, su conjunto de instrucciones, y sus modos de direccionamiento.}
	\begin{center}
		\textbf{Clases de computadoras}
	\end{center}
\begin{itemize}
\item PC - workstation
\item Servidor
\item Cluster
\item SuperComputadora (cientos de miles de procesadores, terabytes, petabytes)
\item Sistemas embebidos
\end{itemize}
\end{frame}
 


\begin{frame}
\frametitle{Arquitecturas y Organización de Computadoras}
\textbf{Terminología}
\begin{itemize}
	\item  \textbf{Arquitectura}: (tambien ISA: instruction set architecture) Los componentes del diseño del procesador 
que necesitan ser comprendidos para programar una computadora.
Ejemplos: especificacion del conjunto de instrucciones, registros, modos de direccionamiento.
\item  \textbf{Microarquitectura}: Implementación de la Arquitectura.
Ejemplos: ejecución out-of-order, pipeling, ejecución especulativa, tamaño de caches, frecuencia del reloj.
\item \textbf{Ejemplos de ISAs}: x86, IA, MIPS, ARM, SPARC, SUPERH, VAX, 68000, AVR

\end{itemize}
\end{frame}



\begin{frame}
	\textbf{Architecture vs. Microarchitecture} \\	
\begin{itemize}
	\item	\textit{Arquitectura (Instruction Set Architecture):}	
\begin{itemize}
	\item Estado visible al programador (memoria y registros)
	\item Operaciones (Instrucciones, y sus acciones)
	\item Semántica de ejecución (interrupciones)
	\item Entrada/Salida
	\item Tipos de datos (tamaños)
\end{itemize}
\item	\textit{Organizacion (Microarquitectura):}	
\begin{itemize}
	\item Compromiso en como implementar un ISA para alguna métrica (rendimiento, consumo, costo)
\item Ejemplos: profundidad del pipeling,  número de pipelings, tamaño de caches, área del chip, potencia pico, orden de ejecución, ancho de bus, ancho de la ALU
\end{itemize}
\end{itemize}
\end{frame}


\begin{frame}
\frametitle{Historia del concepto Arquitectura}
	\begin{itemize}

		\item	\textbf{Problema de compatibilidad de IBM} \\
	Durante 1960's, IBM tuvo 4 líneas de computadoras incompatibles!
	\begin{itemize}
		\item 701 ⇒ 7094
		\item 650 ⇒ 7074
		\item 702 ⇒ 7080
		\item 1401 ⇒ 7010 
	\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Historia del concepto Arquitectura}
	\begin{itemize}
		\item\textbf{Problema de compatibilidad de IBM} \\
	Durante 1960's, IBM tuvo 4 líneas de computadoras incompatibles!
	\begin{itemize}
		\item 701 ⇒ 7094
		\item 650 ⇒ 7074
		\item 702 ⇒ 7080
		\item 1401 ⇒ 7010
	\end{itemize}
\item \textit{Cada sistema tuvo su propio}
	\begin{itemize}
		\item Conjunto de instrucciones
		\item Sistema de E/S y almacenamiento secundario (cintas magnetica, tambores y discos)
		\item ensambladores, compiladores, bibliotecas
		\item diferentes mercados: científico, comercial/bancario, tiempo real
	\end{itemize}
	\end{itemize}
\end{frame}


\begin{frame}
\frametitle{Historia del concepto Arquitectura}
	\begin{itemize}
		\item\textbf{Problema de compatibilidad de IBM} \\
	Durante 1960's, IBM tuvo 4 líneas de computadoras incompatibles!
	\begin{itemize}
		\item 701 ⇒ 7094
		\item 650 ⇒ 7074
		\item 702 ⇒ 7080
		\item 1401 ⇒ 7010
	\end{itemize}
\item \textit{Cada sistema tuvo su propio}
	\begin{itemize}
		\item Conjunto de instrucciones
		\item Sistema de E/S y almacenamiento secundario (cintas magnetica, tambores y discos)
		\item ensambladores, compiladores, bibliotecas
		\item diferentes mercados: científico, comercial/bancario, tiempo real
	\end{itemize}
\item	\textbf{ Respuesta de IBM: ==⇒ IBM	360 == }
	\end{itemize}
\end{frame}






\begin{frame}
\frametitle{IBM 360}
\begin{figure}
\includegraphics[scale=0.2]{IBM-360.jpg} 
\caption{Implementaciones iniciales del IBM 360}
\label{Implementacione Iniciales del IBM 360}
\end{figure}

	\begin{itemize}
	\item Estado del procesador: 16 registros de 32-bit de propósito general, 4 de punto flotante, PC, flags
	\item Arquitectura de 32-bits con direcciones de 24 bits
	\item Formato de datos: bytes de 8-bits, palabra de 32-bits, half y double
	\item \textbf{Primera familia de computadoras con un mismo ISA} 
	\end{itemize}
\end{frame}




\begin{frame}

	\begin{center}
\includegraphics[scale=0.3]{zseries.jpg} 
	\end{center}

\end{frame}


\begin{frame}

\frametitle{Arquitecturas y Organización de Computaodoras}
	\textbf{Ejemplo: misma Arquitectura pero diferente Microarquitectura (Organización)}
	\begin{center}
\includegraphics[scale=0.3]{amd-vs-intel.jpg} 
	\end{center}

\end{frame}


\begin{frame}
\frametitle{Arquitecturas y Organización de Computadoras}
\textbf{Programación de la máquina}
\begin{itemize}
	\item Origen del concepto Arquitectura y Organización (nuevamente)
	\item \textbf{El lenguaje de la máquina}
	\item \textbf{Evolucion: CISC, RISC, multiprocesadores}
\end{itemize}
\end{frame}



\begin{frame}
\frametitle{Programación de la máquina}
	\textbf{Modelo de programación (Arquitectura)}
\begin{figure}
\includegraphics[scale=0.3]{componentes-CPU.jpg} 
\caption{Componentes de la máquina}
\label{Componentes de la máquina}
\end{figure}
	\textit{Estado visible al programador}
	\begin{itemize}
		\item \textbf{Registros} PC, propósito general, stack pointer\\
		\item \textbf{Memoria}: arreglo direccionable por byte. Codigo y datos de usuario. Pila y memoria dinamica
	\end{itemize}
\end{frame}


\begin{frame}
\frametitle{Programación de la máquina}
	\begin{center}
\textbf{Lenguaje Ensamblador}
\includegraphics[scale=0.6]{assembly.jpg} 
	\end{center}
% grafico inicio de RISC: quitar el interprete, hacer un set sencillo, fijo y de pocos formatos
\end{frame}


\begin{frame}
\frametitle{Programación de la máquina}
	\begin{center}
\textbf{Ejemplo de lenguaje máquina: arquitectura x86}
\includegraphics[scale=0.3]{x86-ejemplo.jpg} 
	\end{center}
CISC: instruccion leal, instrucciones con dos operandos, multiples modos de direccionamiento, ancho de instrucciones variable, registros ax, eax, rex \\
% grafico inicio de RISC: quitar el interprete, hacer un set sencillo, fijo y de pocos formatos
\end{frame}


\begin{frame}
\frametitle{Programación de la máquina}
	\begin{center}
	\textbf{Arquitectura x86 (CISC)}
	\end{center}
\begin{tabular}{cl}

\begin{tabular}{c}
\includegraphics[height=5cm, width=3cm]{x86-registros.jpg} 

\end{tabular}
& \begin{tabular}{l}
\parbox{0.5\linewidth}{

\includegraphics[height=2cm, width=6cm]{x86-registro.jpg} 
}
\end{tabular} \\

\end{tabular}
\end{frame}
 


\begin{frame}
\frametitle{Programación de la máquina}
	\begin{center}
	\textbf{Ejemplo de lenguaje máquina: arquitectura MIPS}
	\end{center}
\begin{tabular}{cl}

\begin{tabular}{c}
\includegraphics[height=6cm, width=3.5cm]{compilar-MIPS.jpg} 

\end{tabular}
& \begin{tabular}{l}
\parbox{0.5\linewidth}{
	\textbf{Arquitectura de 32-bits}: numeroso archivo de 32 registros de propósito general, de 32-bits, ALU de 32bits \\
	\textbf{Instrucciones de tamaño fijo}: de 32-bits, sólo 3 formatos de instrucciones \\
	\textbf{Operaciones de ALU de 3 registros}: Caso común (a = b + c)
}
\end{tabular} \\

\end{tabular}
\end{frame}



\begin{frame}
\frametitle{Programación de la máquina}
	\begin{center}
		\textbf{Conjunto de Instrucciones Reales (ISAs)}
\includegraphics[scale=0.3]{real-arquitecturas.jpg} 
	\end{center}
\end{frame}



\begin{frame}
\frametitle{Programación de la máquina}
	\begin{center}
		\textbf{Evolucion CISC, RISC y multiprocesadores}
\includegraphics[scale=0.3]{performance-procesadores.jpg} 
	\end{center}
\end{frame}



\begin{frame}
\frametitle{Programación de la máquina}
\begin{center}
\textbf{Repaso: ISA vs Microarquitectura}
\end{center}
\begin{tabular}{cl}

\begin{tabular}{c}
\includegraphics[height=5cm, width=3cm]{org-estructurada.jpg} 

\end{tabular}
& \begin{tabular}{l}
\parbox{0.6\linewidth}{

	\begin{itemize}
		\item ISA
	\begin{itemize}
		\item Registros (cantidad, propósito)
		\item Formato de instrucciones
		\item Tipos de datos
		\item Cantidad de instrucciones
		\item Modos de direccionamiento
		\item	\textit{Aprendizaje via programación real}
	\end{itemize}
\item Microarquitectura: 
	\begin{itemize}
\item Interpretada (CISC)
\item Implementada en hardware (RISC)
\item \textit{Conceptos teóricos}
	\end{itemize}
	\end{itemize}
}
\end{tabular} \\

\end{tabular}
\end{frame}
 



\begin{frame}

	\begin{center}
\includegraphics[scale=0.4]{compilar-mips.jpg} 
	\end{center}

\end{frame}





% INDICE: HISTORIA de procesadores y arquitectura (filmina de arquitectura de david), system 360, zseries, 
% compilacion, ensamblado, codigo maquina
% ejemplo x86 , uso de longitud variable para instruccciones, instrucciongs con dos operandos, pocos registros, infinidad de modos de direccion2miento para cada operacion. En cada version nuevas instrucciones y compatibilidad. Cientos de instrucciones CISC
% Microarquitectura : programada (interprete), en hardware
% grafico inicio de RISC: quitar el interprete, hacer un set sencillo, fijo y de pocos formatos
% limite de energia, nacimiento de arquitecturas avanzadas 
%
% lenguaje ensamblador, figura de compilacion, ejemplo de ensamblador x86, figura de dos arquitecturas x86, system 360, zseries,X , filmina de diferencia entre arquitectura y organizacion, estructura por capas y resumen de los temas a ver en la materia,  memoria, 
% segunda parte: antes de ver lenguaje ensamblador veremos terminologia importante sobre la organizacion  de la memoria
% Representación de datos a nivel de máquina. Direccionamiento de memoria: concepto de palabra, ordenamiento de bytes. Registros.} 
% memori2, direccion, byte, palabra, alineacion, endianess, instrucciones y datos
% directivas MIPS, etc para el practico

\begin{frame}
\frametitle{Computadora}

x86 assembly language is a family of backward-compatible assembly languages, which provide some level of compatibility all the way back to the Intel 8008 introduced in April 1972. x86 assembly languages are used to produce object code for the x86 class of processors. Like all assembly languages, it uses short mnemonics to represent the fundamental instructions that the CPU in a computer can understand and follow. Compilers sometimes produce assembly code as an intermediate step when translating a high level program into machine code. Regarded as a programming language, assembly coding is machine-specific and low level. Assembly languages are more typically used for detailed and time critical applications such as small real-time embedded systems or operating system kernels and device drivers.
%\begin{figure}
%\includegraphics[scale=0.5]{maq-von-neumann.jpg} 
%\caption{Modelo de Von Neumann}
%\label{Modelo de Von Neumann}
%\end{figure}
% ¿programa-almacenado?
\end{frame}
 
 
 
 



\begin{frame}
 \frametitle{Consejos y preguntas}
\begin{center}
\begin{itemize}
\item  ¿Preguntas?
\end{itemize}
\end{center}
\end{frame}


\begin{frame}
 \frametitle{Bibliografía}
Libros
\begin{itemize}
\item Andrew S. Tanenbaum (2000), ORGANIZACIÓN DE COMPUTADORAS un enfoque estructurado, Editorial Prentice Hall. (10 copias en biblioteca)
\item David. Patterson John L. Hennessy (1995), ORGANIZACIÓN Y DISEÑO DE COMPUTADORES La interfaz hardware/software, McGraw-Hill (8 copias en biblioteca).
\end{itemize}
Contenido electrónico
\begin{itemize}
	\item \textbf{x86 assembly basis} Una introducción al lenguaje ensamblador x86. Disponible en PEDCO en formato PDF.
		\url{https://www.nayuki.io/page/a-fundamental-introduction-to-x86-assembly-programming}
\item Apuntes elaborados por la cátedra, disponibles en PEDCO para impresión (pdf) o lectura online (html)
\item Secciones de libros aptas para publicacion
\end{itemize}
\end{frame}


\end{document}
